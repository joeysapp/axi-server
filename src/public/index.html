<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>AxiDraw Control Panel</title>
  <style>
    :root {
      --bg: #1a1a2e;
      --surface: #16213e;
      --surface-light: #1f3460;
      --primary: #e94560;
      --primary-hover: #ff6b6b;
      --success: #4ecca3;
      --warning: #ffc107;
      --text: #eee;
      --text-dim: #888;
      --radius: 8px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding: 16px;
    }

    .container {
      max-width: 600px;
      margin: 0 auto;
    }

    header {
      text-align: center;
      margin-bottom: 20px;
    }

    header h1 {
      font-size: 1.5rem;
      font-weight: 600;
    }

    .status-bar {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      margin-top: 8px;
      font-size: 0.875rem;
    }

    .status-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--text-dim);
    }

    .status-dot.connected { background: var(--success); }
    .status-dot.disconnected { background: var(--primary); }
    .status-dot.busy { background: var(--warning); animation: pulse 1s infinite; }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .card {
      background: var(--surface);
      border-radius: var(--radius);
      padding: 16px;
      margin-bottom: 16px;
    }

    .card h2 {
      font-size: 0.875rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-dim);
      margin-bottom: 12px;
    }

    .btn-row {
      display: flex;
      gap: 8px;
    }

    .btn {
      flex: 1;
      padding: 12px 16px;
      border: none;
      border-radius: var(--radius);
      background: var(--surface-light);
      color: var(--text);
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
      touch-action: manipulation;
    }

    .btn:hover { background: #2a4a7f; }
    .btn:active { transform: scale(0.98); }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }

    .btn.primary { background: var(--primary); }
    .btn.primary:hover { background: var(--primary-hover); }

    .btn.success { background: var(--success); color: #000; }
    .btn.success:hover { background: #6eecc3; }

    .btn.warning { background: var(--warning); color: #000; }

    .btn.small {
      padding: 8px 12px;
      font-size: 0.8rem;
    }

    /* D-Pad */
    .dpad-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }

    .dpad-row {
      display: flex;
      gap: 4px;
    }

    .dpad-btn {
      width: 64px;
      height: 64px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      background: var(--surface-light);
      border: none;
      border-radius: var(--radius);
      color: var(--text);
      cursor: pointer;
      transition: all 0.1s;
      touch-action: manipulation;
      user-select: none;
    }

    .dpad-btn:hover { background: #2a4a7f; }
    .dpad-btn:active { background: var(--primary); transform: scale(0.95); }

    .dpad-btn.home {
      font-size: 1rem;
      background: var(--warning);
      color: #000;
    }

    .dpad-placeholder {
      width: 64px;
      height: 64px;
    }

    /* Position Display */
    .position-display {
      display: flex;
      justify-content: center;
      gap: 24px;
      padding: 16px;
      background: var(--surface-light);
      border-radius: var(--radius);
      font-family: 'SF Mono', Monaco, monospace;
      font-size: 1.25rem;
    }

    .position-display .coord {
      display: flex;
      align-items: baseline;
      gap: 4px;
    }

    .position-display .label {
      color: var(--text-dim);
      font-size: 0.875rem;
    }

    .position-display .value {
      min-width: 80px;
      text-align: right;
    }

    /* Canvas Display */
    .canvas-container {
      width: 100%;
      height: 200px; /* Base height, scaled by JS depending on bounds */
      background: #ffffff;
      border-radius: var(--radius);
      margin-top: 16px;
      overflow: hidden;
      position: relative;
    }

    #plotterCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    /* Sliders */
    .slider-group {
      margin-bottom: 16px;
    }

    .slider-group:last-child {
      margin-bottom: 0;
    }

    .slider-label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      font-size: 0.875rem;
    }

    .slider-label .value {
      color: var(--primary);
      font-weight: 600;
    }

    input[type="range"] {
      width: 100%;
      height: 8px;
      border-radius: 4px;
      background: var(--surface-light);
      appearance: none;
      outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--primary);
      cursor: pointer;
    }

    /* SVG Upload */
    .upload-zone {
      border: 2px dashed var(--surface-light);
      border-radius: var(--radius);
      padding: 24px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
    }

    .upload-zone:hover, .upload-zone.dragover {
      border-color: var(--primary);
      background: rgba(233, 69, 96, 0.1);
    }

    .upload-zone input {
      display: none;
    }

    .upload-zone .icon {
      font-size: 2rem;
      margin-bottom: 8px;
    }

    .upload-zone p {
      color: var(--text-dim);
      font-size: 0.875rem;
    }

    /* Queue */
    .queue-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px;
      background: var(--surface-light);
      border-radius: var(--radius);
      margin-bottom: 8px;
    }

    .queue-item:last-child {
      margin-bottom: 0;
    }

    .queue-item .name {
      font-weight: 500;
    }

    .queue-item .status {
      font-size: 0.75rem;
      padding: 4px 8px;
      border-radius: 4px;
      background: var(--surface);
    }

    .queue-item .status.running {
      background: var(--success);
      color: #000;
    }

    .queue-empty {
      text-align: center;
      color: var(--text-dim);
      padding: 16px;
    }

    /* Toast notifications */
    .toast-container {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
    }

    .toast {
      background: var(--surface);
      color: var(--text);
      padding: 12px 20px;
      border-radius: var(--radius);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      margin-top: 8px;
      animation: slideUp 0.3s ease;
    }

    .toast.error {
      background: var(--primary);
    }

    .toast.success {
      background: var(--success);
      color: #000;
    }

    @keyframes slideUp {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* Pen indicator */
    .pen-indicator {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 8px 16px;
      background: var(--surface-light);
      border-radius: var(--radius);
      margin-bottom: 12px;
    }

    .pen-icon {
      font-size: 1.25rem;
      transition: transform 0.3s;
    }

    .pen-icon.down {
      transform: translateY(4px);
      color: var(--success);
    }

    .pen-icon.up {
      color: var(--text-dim);
    }

    /* API Host Config */
    .api-config {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
    }

    .api-config input {
      flex: 1;
      padding: 8px 12px;
      border: 1px solid var(--surface-light);
      border-radius: var(--radius);
      background: var(--surface-light);
      color: var(--text);
      font-size: 0.875rem;
    }

    .api-config input:focus {
      outline: none;
      border-color: var(--primary);
    }

    /* Note about hosting */
    .hosting-note {
      font-size: 0.75rem;
      color: var(--text-dim);
      text-align: center;
      margin-top: 16px;
      padding: 12px;
      background: var(--surface);
      border-radius: var(--radius);
      line-height: 1.5;
    }

    .hosting-note code {
      background: var(--surface-light);
      padding: 2px 6px;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div class="container">
   <header style="display: flex; justify-content: space-between; align-items: center;">
     <h1 style="font-family: monospace;">axi-core</h1>
      <div class="status-bar">
        <span class="status-dot" id="statusDot"></span>
        <span id="statusText">Checking...</span>
      </div>
    </header>

    <!-- Position & Canvas -->
    <div class="card" style="padding: 12px; margin-bottom: 12px;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
        <h2 style="margin:0;">Canvas</h2>
        <div style="font-family: monospace; font-size: 0.9rem; color: var(--text-dim);">
          X: <span id="posX" style="color:var(--text);">0.00</span> | Y: <span id="posY" style="color:var(--text);">0.00</span> mm | <span class="" id="penStatus">Pen Unknown</span>
        </div>
      </div>
      <div class="canvas-container" style="margin-top: 4px;">
        <canvas id="plotterCanvas"></canvas>
      </div>
     <div class="btn-row" style="margin-top: 8px;">
        <button class="btn small success" onclick="goHome()">Go Home</button>	  
        <button class="btn small" onclick="downloadPathSVG()">Save SVG</button>
        <button class="btn small warning" onclick="clearPath()">Clear Path</button>
      </div>
    </div>
    <!-- Pen Control -->
    <div class="card" style="padding: 12px; margin-bottom: 12px;">
      <h2 style="margin-bottom: 8px;">Controls</h2>
          <div class="dpad-container" style="gap: 2px;">
            <div class="dpad-row" style="gap: 2px;">
              <button class="dpad-btn" style="width:40px; height:40px;" onpointerdown="startMove(-1, -1)" onpointerup="stopMove()" onpointerleave="stopMove()">&#8598;</button>
              <button class="dpad-btn" style="width:40px; height:40px;" onpointerdown="startMove(0, -1)" onpointerup="stopMove()" onpointerleave="stopMove()">&#8593;</button>
              <button class="dpad-btn" style="width:40px; height:40px;" onpointerdown="startMove(1, -1)" onpointerup="stopMove()" onpointerleave="stopMove()">&#8599;</button>
            </div>
            <div class="dpad-row" style="gap: 2px;">
             <button class="dpad-btn" style="width:40px; height:40px;" onpointerdown="startMove(-1, 0)" onpointerup="stopMove()" onpointerleave="stopMove()">&#8592;</button>
             <button class="dpad-btn" id="penButton" style="width:40px; height:40px; font-size: 0.7rem;" onclick="penToggle()">
			  <span class="pen-icon" id="penIcon">&#9999;&#65039;</span>
			 </button>			 
             
             <button class="dpad-btn home" style="display: none; width:40px; height:40px; font-size: 0.7rem;" onclick="goHome()">HOME</button>
              <button class="dpad-btn" style="width:40px; height:40px;" onpointerdown="startMove(1, 0)" onpointerup="stopMove()" onpointerleave="stopMove()">&#8594;</button>
            </div>
            <div class="dpad-row" style="gap: 2px;">
              <button class="dpad-btn" style="width:40px; height:40px;" onpointerdown="startMove(-1, 1)" onpointerup="stopMove()" onpointerleave="stopMove()">&#8601;</button>
              <button class="dpad-btn" style="width:40px; height:40px;" onpointerdown="startMove(0, 1)" onpointerup="stopMove()" onpointerleave="stopMove()">&#8595;</button>
              <button class="dpad-btn" style="width:40px; height:40px;" onpointerdown="startMove(1, 1)" onpointerup="stopMove()" onpointerleave="stopMove()">&#8600;</button>
            </div>
          </div>
    </div>

    <!-- SVG Upload & Queue -->
    <div class="card" style="padding: 12px; margin-bottom: 12px;">
      <div style="display: flex; gap: 12px; align-items: stretch; flex-wrap: wrap;">
        <div class="upload-zone" id="uploadZone" onclick="document.getElementById('svgFile').click()" style="flex: 1; padding: 12px; min-width: 150px; display: flex; flex-direction: column; justify-content: center;">
          <input type="file" id="svgFile" accept=".svg,image/svg+xml" onchange="uploadSVG(event)">
          <div class="icon" style="font-size: 1.5rem; margin-bottom: 4px;">&#128196;</div>
          <p style="margin:0;">Click/Drag SVG</p>
        </div>
        <div style="flex: 2; display: flex; flex-direction: column; min-width: 200px;">
          <div id="queueList" style="flex: 1; max-height: 80px; overflow-y: auto; background: var(--surface-light); border-radius: var(--radius); padding: 4px;">
            <div class="queue-empty" style="padding: 8px;">No jobs in queue</div>
          </div>
          <div class="btn-row" style="margin-top: 4px;">
            <button class="btn small" onclick="pauseQueue()">Pause</button>
            <button class="btn small" onclick="resumeQueue()">Resume</button>
           <button class="btn small warning" onclick="clearQueue()">Clear</button>
          <button class="btn primary small" onclick="emergencyStop()">STOP</button>		   
          </div>
        </div>
      </div>
    </div>

    <!-- Pen Control -->
    <div class="card" style="padding: 12px; margin-bottom: 12px;">
      <h2 style="margin-bottom: 8px;">Speed</h2>
      <div style="display: flex; gap: 16px; flex-wrap: wrap;">
        <div style="flex: 1; min-width: 140px; display: flex; justify-content: center;">

        <div style="flex: 2; display: flex; flex-direction: column; gap: 8px; min-width: 180px;">
          <div class="slider-group" style="margin:0;">
            <div class="slider-label" style="margin-bottom: 2px;">
              <span>Step</span>
              <span class="value"><span id="stepValue">5</span> mm</span>
            </div>
            <input type="range" id="stepSize" min="1" max="50" value="5" oninput="updateStep()">
          </div>
          <div class="slider-group" style="margin:0;">
            <div class="slider-label" style="margin-bottom: 2px;">
              <span>Dn Speed</span>
              <span class="value"><span id="speedDownValue">1.5</span> in/s</span>
            </div>
            <input type="range" id="speedDown" min="0.5" max="5" step="0.1" value="1.5" oninput="updateSpeedDisplay()" onchange="setSpeed()">
          </div>
          <div class="slider-group" style="margin:0;">
            <div class="slider-label" style="margin-bottom: 2px;">
              <span>Up Speed</span>
              <span class="value"><span id="speedUpValue">3.0</span> in/s</span>
            </div>
            <input type="range" id="speedUp" min="1" max="15" step="0.5" value="3.0" oninput="updateSpeedDisplay()" onchange="setSpeed()">
          </div>
          </div>		   
		  </div>
		   
		  </div>		 
		</div>

    <!-- AxiDraw Host configuration -->
    <div class="card" style="padding: 12px; margin-bottom: 20vh;">
      <h2 style="margin-bottom: 8px;">AxiDraw Host</h2>
      <div class="api-config" style="display: flex; flex-direction: column; margin-bottom: 0;">
       <input type="text" id="apiHost" placeholder="http://localhost:9700" style="padding: 6px 10px;">
		<div class="display: flex; justify-content: space-between;">
        <button class="btn small" id="connectBtn" onclick="connect()">Connect</button>
         <button class="btn primary small" id="disconnectBtn" onclick="disconnect()">Disconnect</button>
         <button class="btn success small" onclick="updateApiHost()">Save to Browser</button>
		 </div>
      </div>
    </div>



  <div class="toast-container" id="toasts"></div>

  <script>
    // Configuration - can be changed to point to any AxiDraw server
    let API_BASE = '';

    // Initialize API base from current location or localStorage
    function initApiBase() {
      const saved = localStorage.getItem('axiApiHost');
      if (saved) {
        API_BASE = saved;
      } else {
        // Default to same origin
        API_BASE = window.location.origin;
      }
      document.getElementById('apiHost').value = API_BASE;
    }

    function updateApiHost() {
      const input = document.getElementById('apiHost').value.trim();
	  // Remove trailing slash	  
      // API_BASE = input.replace(/\\/$/, '');
      localStorage.setItem('axiApiHost', API_BASE);
      toast('API host updated', 'success');
      refreshStatus();
    }

    // Toast notifications
    function toast(message, type = 'info') {
      const container = document.getElementById('toasts');
      const el = document.createElement('div');
      el.className = 'toast ' + type;
      el.textContent = message;
      container.appendChild(el);
      setTimeout(() => el.remove(), 3000);
    }

    // API helpers
    async function api(endpoint, options = {}) {
      try {
        const res = await fetch(API_BASE + endpoint, {
          ...options,
          headers: {
            'Content-Type': 'application/json',
            ...options.headers
          }
        });
        const data = await res.json();
        if (data.error) throw new Error(data.error);
        return data;
      } catch (e) {
        toast(e.message, 'error');
        throw e;
      }
    }

    async function post(endpoint, body = {}) {
      return api(endpoint, { method: 'POST', body: JSON.stringify(body) });
    }

    // WebSocket Connection
    let ws;
    function connectWebSocket() {
      const wsUrl = API_BASE.replace(/^http/, 'ws') + '/spatial';
      ws = new WebSocket(wsUrl);
      
      ws.onopen = () => {
        const dot = document.getElementById('statusDot');
        const text = document.getElementById('statusText');
        dot.className = 'status-dot connected';
        text.textContent = 'Connected (WS)';
      };
      
      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          if (data.type === 'state' || data.type === 'connected') {
            if (data.position && data.position.x !== undefined) {
              document.getElementById('posX').textContent = data.position.x.toFixed(2);
              document.getElementById('posY').textContent = data.position.y.toFixed(2);
            }
            if (data.penDown !== undefined) {
             const penIcon = document.getElementById('penIcon');
             const penButton = document.getElementById('penButton');			 
             const penStatus = document.getElementById('penStatus');
             penButton.className = 'dpad-btn ' + (data.penDown ? 'primary' : 'warning');			 
              penIcon.className = 'pen-icon ' + (data.penDown ? 'down' : 'up');
             penStatus.textContent = data.penDown ? 'Pen Down' : 'Pen Up';
             penStatus.className = data.penDown ? 'primary' : '';			 
            }
          }
        } catch(e) {}
      };
      
      ws.onclose = () => {
        setTimeout(connectWebSocket, 3000);
      };
    }

    // Status polling
    let statusInterval;

    async function refreshStatus() {
      try {
        const data = await api('/health');
        const dot = document.getElementById('statusDot');
        const text = document.getElementById('statusText');

        if (data.connected && (!ws || ws.readyState !== WebSocket.OPEN)) {
          dot.className = 'status-dot connected';
          text.textContent = 'Connected - ' + (data.state || 'ready');
        } else if (!data.connected) {
          dot.className = 'status-dot disconnected';
          text.textContent = 'Disconnected';
        }

        const status = await api('/status');

        // Update queue
        const queue = await api('/queue');
        updateQueueDisplay(queue);

        // Update speed sliders safely
        const speed = await api('/speed');
        if (speed.speed) {
          if (document.activeElement !== document.getElementById('speedDown')) {
            document.getElementById('speedDown').value = speed.speed.penDown;
          }
          if (document.activeElement !== document.getElementById('speedUp')) {
            document.getElementById('speedUp').value = speed.speed.penUp;
          }
          updateSpeedDisplay();
        }

        // Update canvas
        try {
          const pathRes = await api('/path');
          updateCanvas(pathRes.path, pathRes.bounds, status.motion?.position?.mm);
        } catch (e) {
          // ignore canvas update errors
        }
      } catch (e) {
        document.getElementById('statusDot').className = 'status-dot disconnected';
        document.getElementById('statusText').textContent = 'Server unreachable';
      }
    }

    function updateCanvas(path, bounds, currentPos) {
      const canvas = document.getElementById('plotterCanvas');
      if (!canvas) return;

      const container = canvas.parentElement;
      const dpr = window.devicePixelRatio || 1;
      
      const rect = container.getBoundingClientRect();
      const logicalWidth = rect.width;
      const logicalHeight = (bounds.maxY / bounds.maxX) * logicalWidth;
      
      canvas.width = logicalWidth * dpr;
      canvas.height = logicalHeight * dpr;
      canvas.style.width = logicalWidth + 'px';
      canvas.style.height = logicalHeight + 'px';
      container.style.height = logicalHeight + 'px';

      const ctx = canvas.getContext('2d');
      ctx.scale(dpr, dpr);
      ctx.clearRect(0, 0, logicalWidth, logicalHeight);

      const scaleX = logicalWidth / bounds.maxX;
      const scaleY = logicalHeight / bounds.maxY;

      // Draw path with segments for proper styling
      if (path && path.length > 0) {
        let lastPt = path[0];
        
        for (let i = 1; i < path.length; i++) {
          const pt = path[i];
          
          if (lastPt.penDown) {
            ctx.beginPath();
            ctx.moveTo(lastPt.x * scaleX, lastPt.y * scaleY);
            ctx.lineTo(pt.x * scaleX, pt.y * scaleY);
            ctx.strokeStyle = '#e94560'; // Primary color (thick/opaque)
            ctx.lineWidth = 2;
            ctx.globalAlpha = 1.0;
            ctx.stroke();
          }
          // Do not draw travel lines (pen up) to avoid clutter
          
          lastPt = pt;
        }
      }

      // Draw home
      ctx.fillStyle = '#ffc107'; // Warning color
      ctx.beginPath();
      ctx.arc(0, 0, 4, 0, Math.PI * 2);
      ctx.fill();

      // Draw current position
      if (currentPos) {
        // Red if pen is down, green if pen is up
        ctx.fillStyle = document.getElementById('penStatus').textContent === 'Pen Down' ? '#e94560' : '#4ecca3';
        ctx.beginPath();
        ctx.arc(currentPos.x * scaleX, currentPos.y * scaleY, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1;
        ctx.stroke();
      }
    }

    function updateQueueDisplay(data) {
      const container = document.getElementById('queueList');
      const jobs = data.jobs || [];

      if (jobs.length === 0) {
        container.innerHTML = '<div class="queue-empty">No jobs in queue</div>';
        return;
      }

      container.innerHTML = jobs.map(job => {
	  return `
        <div class="queue-item">
          <div>
            <div class="name">\${job.name || 'Unnamed'}</div>
            <div style="font-size: 0.75rem; color: var(--text-dim);">\${job.progress || 0}%</div>
          </div>
          <span class="status \${job.state === 'running' ? 'running' : ''}">\${job.state}</span>
        </div>
      `;
	  }).join('');
    }

    // Connection
    async function connect() {
      await post('/connect');
      toast('Connected!', 'success');
      refreshStatus();
    }

    async function disconnect() {
      await post('/disconnect');
      toast('Disconnected', 'info');
      refreshStatus();
    }

    // Pen control
    async function penUp() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'event', action: 'pen_up' }));
      } else {
        await post('/pen/up');
        refreshStatus();
      }
    }

    async function penDown() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'event', action: 'pen_down' }));
      } else {
        await post('/pen/down');
        refreshStatus();
      }
    }

    async function penToggle() {
     if (ws && ws.readyState === WebSocket.OPEN) {
       ws.send(JSON.stringify({ type: 'event', action: 'pen_toggle' }));
      } else {
        await post('/pen/toggle');
        refreshStatus();
      }
    }

    // Movement
    function getStepSize() {
      return parseFloat(document.getElementById('stepSize').value);
    }

    function updateStep() {
      document.getElementById('stepValue').textContent = getStepSize();
    }

    function startMove(dx, dy) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        // Base speed based on step size slider (1-50 -> 10-200 mm/s approx)
        const speed = (getStepSize() / 50) * 200;
        ws.send(JSON.stringify({
          type: 'spatial',
          ts: Date.now(),
          velocity: { x: dx * speed, y: dy * speed, z: 0 }
        }));
      } else {
        // Fallback to HTTP coalesce move if no WS
        const step = getStepSize();
        post('/move?coalesce=50', { dx: dx * step, dy: dy * step, units: 'mm' }).then(refreshStatus);
      }
    }

    function stopMove() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          type: 'spatial',
          ts: Date.now(),
          velocity: { x: 0, y: 0, z: 0 }
        }));
      }
    }

    async function goHome() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'event', action: 'home' }));
        toast('Moving home...', 'info');
      } else {
        await post('/home');
        toast('Moving home...', 'info');
        refreshStatus();
      }
    }

    // Speed
    function updateSpeedDisplay() {
      document.getElementById('speedDownValue').textContent = document.getElementById('speedDown').value;
      document.getElementById('speedUpValue').textContent = document.getElementById('speedUp').value;
    }

    async function setSpeed() {
      const penDown = parseFloat(document.getElementById('speedDown').value);
      const penUp = parseFloat(document.getElementById('speedUp').value);
      await post('/speed', { penDown, penUp });
      toast('Speed updated', 'success');
    }

    // SVG Upload
    const uploadZone = document.getElementById('uploadZone');

    uploadZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      uploadZone.classList.add('dragover');
    });

    uploadZone.addEventListener('dragleave', () => {
      uploadZone.classList.remove('dragover');
    });

    uploadZone.addEventListener('drop', (e) => {
      e.preventDefault();
      uploadZone.classList.remove('dragover');
      const file = e.dataTransfer.files[0];
      if (file) handleSVGFile(file);
    });

    function uploadSVG(event) {
      const file = event.target.files[0];
      if (file) handleSVGFile(file);
    }

    async function handleSVGFile(file) {
      const formData = new FormData();
      formData.append('file', file);

      try {
        const res = await fetch(API_BASE + '/svg/upload', {
          method: 'POST',
          body: formData
        });
        const data = await res.json();
        if (data.error) throw new Error(data.error);
        toast(`Queued: ${file.name} (${data.commandCount} commands)`, 'success');
        refreshStatus();
      } catch (e) {
        toast(e.message, 'error');
      }
    }

    async function clearPath() {
      await post('/path/clear');
      toast('Path history cleared', 'info');
      refreshStatus();
    }

    async function downloadPathSVG() {
      try {
        const res = await api('/path');
        if (!res.svg) throw new Error("No SVG available");
        const blob = new Blob([res.svg], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'axidraw-path.svg';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      } catch (e) {
        toast('Failed to download SVG: ' + e.message, 'error');
      }
    }

    // Queue controls
    async function pauseQueue() {
      await post('/queue/pause');
      toast('Queue paused', 'info');
    }

    async function resumeQueue() {
      await post('/queue/resume');
      toast('Queue resumed', 'success');
    }

    async function clearQueue() {
      await post('/queue/clear');
      toast('Queue cleared', 'info');
      refreshStatus();
    }

    // Emergency stop
    async function emergencyStop() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'event', action: 'stop' }));
        toast('EMERGENCY STOP', 'error');
      } else {
        await post('/stop');
        toast('EMERGENCY STOP', 'error');
        refreshStatus();
      }
    }

    // Initialize
    initApiBase();
    connectWebSocket();
    refreshStatus();
    statusInterval = setInterval(refreshStatus, 2000);
  </script>
</body>
</html>
